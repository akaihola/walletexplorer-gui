<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>Vis Network | Manipulation </title>

    <style type="text/css">
        body,
        select {
            font: 10pt sans;
        }
        body {
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        body > * {
            flex-grow: 0;
            flex-shrink: 0;
            margin: 0;
            padding: 0;
            width: 100%;
        }
        body > #mynetwork {
            flex-grow: 1;
            width: calc(100% - 2px);
            border: 1px solid lightgray;
        }
        table.legend_table {
            font-size: 11px;
            border-width: 1px;
            border-color: #d3d3d3;
            border-style: solid;
        }
        table.legend_table,
        td {
            border-width: 1px;
            border-color: #d3d3d3;
            border-style: solid;
            padding: 2px;
        }
        div.table_content {
            width: 80px;
            text-align: center;
        }
        div.table_description {
            width: 100px;
        }

        #operation {
            font-size: 28px;
        }
        #network-popUp {
            display: none;
            position: absolute;
            top: 350px;
            left: 170px;
            z-index: 299;
            width: 250px;
            height: 120px;
            background-color: #f9f9f9;
            border-style: solid;
            border-width: 3px;
            border-color: #5394ed;
            padding: 10px;
            text-align: center;
        }
    </style>

    <script
            type="text/javascript"
            src="/vis-network/standalone/umd/vis-network.min.js"
    ></script>

    <script
            type="text/javascript"
            src="https://unpkg.com/alea@1.0.0/alea.js"
    ></script>
    <script type="text/javascript" src="/js/exampleUtil.js"></script>

    <script type="text/javascript">
        var nodes = {};
        var edges = {};
        var network = null;
        // make the graph empty when the page is loaded
        var seed = 2;

        function destroy() {
            if (network !== null) {
                network.destroy();
                network = null;
            }
        }

        function logScaler(min, max, total, value) {
            if (max === min) return 0;
            const log_min = Math.log(min);
            const log_max = Math.log(max);
            const log_val = Math.log(value);
            return (log_val - log_min) / (log_max - log_min);
        }

        function truncateFloat(value) {
            if (value < 100) {
                const coeff = Math.pow(10, 2 - Math.ceil(Math.log10(value)));
                return (Math.round(coeff * value) / coeff).toString();
            }
            if (value >= 100000) return truncateFloat(value / 1000000.0) + "M";
            if (value >= 500) return truncateFloat(value / 1000.0) + "k";
            return value.toString()
        }

        function draw() {
            destroy();
            nodes = {};
            edges = {};

            // create a network
            var container = document.getElementById("mynetwork");
            var options = {
                layout: {
                    hierarchical: {
                        direction: "UD"
                    },
                    randomSeed: seed  // just to make sure the layout stays the same when re-drawing
                },
                interaction: { keyboard: true },
                groups: {
                    time: { shape: "text" },
                    transaction: {
                        shape: "ellipse",
                        color: {
                            background: "#bbffff",
                            border: "#384e4e",
                            highlight: {
                                background: "#ffffff",
                                border: "#384e4e"
                            }
                        }
                    },
                    address: {
                        shape: "box",
                        color: {
                            background: "#ffffbb",
                            border: "#4e4e38",
                            highlight: {
                                background: "#ffffff",
                                border: "#4e4e38"
                            }
                        }
                    }
                },
                edges: {
                    arrows: "to",
                    smooth: {
                        type: "horizontal",
                        roundness: 0.4
                    },
                    scaling: {
                        min: 0.2,
                        max: 7,
                        customScalingFunction: logScaler,
                    }
                },
                manipulation: {
                    addNode: function (data, callback) {
                        // filling in the popup DOM elements
                        document.getElementById("operation").innerText = "Add Node";
                        document.getElementById("node-id").value = data.id;
                        document.getElementById("node-label").value = data.label;
                        document.getElementById("saveButton").onclick = saveData.bind(
                            this,
                            data,
                            callback
                        );
                        document.getElementById("cancelButton").onclick =
                            clearPopUp.bind();
                        document.getElementById("network-popUp").style.display = "block";
                    },
                    editNode: function (data, callback) {
                        // filling in the popup DOM elements
                        document.getElementById("operation").innerText = "Edit Node";
                        document.getElementById("node-id").value = data.id;
                        document.getElementById("node-label").value = data.label;
                        document.getElementById("saveButton").onclick = saveData.bind(
                            this,
                            data,
                            callback
                        );
                        document.getElementById("cancelButton").onclick = cancelEdit.bind(
                            this,
                            callback
                        );
                        document.getElementById("network-popUp").style.display = "block";
                    },
                    addEdge: function (data, callback) {
                        if (data.from == data.to) {
                            var r = confirm("Do you want to connect the node to itself?");
                            if (r == true) {
                                callback(data);
                            }
                        } else {
                            callback(data);
                        }
                    },
                },
            };
            network = new vis.Network(
                container,
                { nodes: Object.values(nodes), edges: Object.values(edges) },
                options
            );
            network.once('afterDrawing', () => {
                // work-around for flex layout, see https://github.com/visjs/vis-network/issues/2156
                container.style.height = `${container.scrollHeight - 3}px`;
            })
        }

        function clearPopUp() {
            document.getElementById("saveButton").onclick = null;
            document.getElementById("cancelButton").onclick = null;
            document.getElementById("network-popUp").style.display = "none";
        }

        function cancelEdit(callback) {
            clearPopUp();
            callback(null);
        }

        function saveData(data, callback) {
            data.id = document.getElementById("node-id").value;
            data.label = document.getElementById("node-label").value;
            clearPopUp();
            callback(data);
        }

        function init() {
            draw();
        }

        async function addTransaction() {
            const tx_id = document.getElementById("tx_id").value;
            if (tx_id.length !== 64) {
                alert("Transaction ID must be 64 characters long");
                return;
            }
            await addTx(tx_id);
            network.setData({ nodes: Object.values(nodes), edges: Object.values(edges) });
        }

        async function addTx(tx_id) {
            // Query the transaction from /api/1/tx?txid=:tx_id&caller=walletexplorer-gui
            // and add it to the graph:
            const response = await fetch(`/api/1/tx?txid=${tx_id}&caller=walletexplorer-gui`);
            const data = await response.json();
            const inputTotal = data.in.reduce((sum, input) => sum + input.amount, 0);
            const isodatetime = new Date(data.time * 1000).toISOString().replace("T", " ").replace(/\.\d+Z$/, "");
            nodes[data.time.toString()] = {
                group: "time",
                id: data.time.toString(),
                label: isodatetime,
                blockHeight: data.block_height,
                title: `Block height: ${data.block_height}\n${isodatetime}`
            };
            nodes[tx_id] = {
                group: "transaction",
                id: tx_id,
                label: tx_id.substring(0, 8),
                blockHeight: data.block_height,
                title: `Block height: ${data.block_height}\nTotal input: ${inputTotal}\n${isodatetime}`,
                value: inputTotal,
                shape: "box",
                scaling: {
                    label: {
                        enabled: true,
                        min: 15,
                        max: 40
                    },
                    customScalingFunction: logScaler
                }
            };
            data.out.forEach((output) => {
                nodes[output.address] = {
                    group: "address",
                    id: output.address,
                    label: output.address.substring(0, 8),
                    nextTx: output.next_tx,
                    blockHeight: data.block_height + 0.5,
                    title: `${output.address}\n${output.label || ""}`
                };
                edges[`${tx_id}-${output.address}`] = {
                    from: tx_id,
                    to: output.address,
                    label: truncateFloat(output.amount),
                    value: output.amount,
                    title: `${output.amount.toString()}\n${output.address}`
                };
            });
            data.in.forEach((input) => {
                nodes[input.address] = {
                    group: "address",
                    id: input.address,
                    label: input.address.substring(0, 8),
                    nextTx: input.next_tx,
                    blockHeight: data.block_height - 0.5,
                    title: `${input.address}\n${input.label || ""}`
                };
                edges[`${input.address}-${tx_id}`] = {
                    from: input.address,
                    to: tx_id,
                    label: truncateFloat(input.amount),
                    value: input.amount,
                    title: `${input.amount.toString()}\n${input.address}`
                };
            });
            const heights = new Set(
                Object.values(nodes)
                    .map((node) => node.blockHeight)
            );
            const heightPositions = {};
            [...heights].sort().map((height, index) => {
                heightPositions[height] = index;
            });
            Object.values(nodes)
                .forEach((node) => {
                    node.level = heightPositions[node.blockHeight];  // only has effect in hierarchical layout
                });
        }

        async function expandAddress() {
            const selectedNodeIds = network.getSelectedNodes();
            const selectdAddresses = selectedNodeIds.filter((nodeId) => nodes[nodeId].group === "address");
            if (selectdAddresses.length === 0) {
                alert("Please select an address node");
                return;
            }
            for (const address of selectdAddresses) {
                await addTx(nodes[address].nextTx);
            };
            network.setData({ nodes: Object.values(nodes), edges: Object.values(edges) });
        }
    </script>
</head>

<body onload="init();">
<header>
<h2>Editing the nodes and edges</h2>
<!-- An input field for pasting transaction IDs: -->
<p>
    <label for="tx_id">Transaction ID:</label>
    <input type="text" id="tx_id" name="tx_id" size="64" maxlength="64">
    <input type="button" value="Add" onclick="addTransaction()">
</p>

<!-- A button for expanding the selected address: -->
<p>
    <input type="button" value="Expand selected address" onclick="expandAddress()">
</p>


<div id="network-popUp">
    <span id="operation">node</span> <br />
    <table style="margin: auto">
        <tr>
            <td>id</td>
            <td><input id="node-id" value="new value" /></td>
        </tr>
        <tr>
            <td>label</td>
            <td><input id="node-label" value="new value" /></td>
        </tr>
    </table>
    <input type="button" value="save" id="saveButton" />
    <input type="button" value="cancel" id="cancelButton" />
</div>
</header>
<div id="mynetwork"></div>
</body>
</html>
